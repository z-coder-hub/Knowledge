# React

#### 说说对 React 的理解？有哪些特性？

> React是一个用于构建用户界面的JavaScript库。
>
> 特点：
>
> - 通过对DOM的模拟，最大程度的减少与DOM的交互
> - **可以和已知的库很好的配合**
> - **jsx语法**
> - **组件化**
> - **单项响应的数据流**





#### 说说 Real DOM 和 Virtual DOM 的区别？优缺点？

> 区别：
>
> - Real DOM是浏览器的真实DOM
>
> - virtual DOM是JavaScript对象



> 优缺点：
>
> Real DOM的优点：浏览器的原生DOM，可以直接操作
>
> Real DOM的缺点：当DOM结构发生改变时，浏览器需要重新布局。损耗性能
>
> virtual DOM的优点：避免了不必要的DOM操作，提升了性能
>
> virtual DOM的缺点：首次渲染计算量大，需要计算virtual DOM的差异



#### 说说React Jsx转换成真实DOM过程？

> **React中的JSX是一种语法=糖**，它可以让我们在JavaScript中编写类似HTML的代码。当我们在React中使用JSX时，它会被转换成真实的DOM元素。这个过程是由Babel编译器完成的。
>
> Babel编译器 会将JSX转换成React.createElement()函数的调用，然后React根据这个函数的返回值来创建真实的DOM元素。







#### 说说对React中合成事件的理解

1. react的合成事件是react中处理浏览器兼容和优化性能的方式
2. 通过事件委托的方式大大减少了创建事件监听器数量
3. 有原生事件同样的事件接口，解决浏览器兼容问题
4. 通过事件池的方式减少事件对象的创建，每次触发一个事件时先回检查事件池中是否有可用的事件对象，如果有则复用，而不是直接创建一个事件对象。这里的事件对象是合成事件对象



#### react子组件不渲染的方式

**类组件**

`PureComponent`继承的方式

```jsx
import React, {PureComponent} from 'react'

class A extends PureComponent {
    render() {
        console.log('我渲染了');
        return (
            <div>
                子组件
            </div>
        );
    }
}

export default A;
```

`shuldComponentUpdate`生命周期的方式

> `PureComponent`实际上就是比较前后的state和props有没有变化，如果没有就不执行render



**函数组件**

`memo`高阶组件的方式

```jsx
import React, {memo} from 'react';

const A = memo(function a(props) {
    console.log('我渲染了');
    return (
        <div>子组件</div>
    );
})



export default A;
```







#### 说说setState的理解

> - 在18版本后是一个纯异步函数
> - 如果在一个方法中定义多个setState，React会将多个合成一个
> - 在同步的代码中是异步的，在异步的代码中
> - 参数说明即可



#### state和props的区别

> 在react中组件分为有状态组件和无状态组件，state就是在有状态的组件中的动态的数据。
>
> state：state一般定义在constructor生命周期中，定义在state中的数据可以页面变化。state如果修改的话需要使用this.setState方法去修改state中的数据。
>
> props：props用来实现react组件通信功能，react的一大特性就是组件化。而组件间通信就是通过props参数接收
>
> 区别：
>
> props是父组件传进来的参数，且参数不可修改
>
> state是定义在类组件中的参数，这个参数可以修改



#### super()和super(props)的区别

> ES6中通过extends关键实现类的继承，在子类中的constructor函数中必须存在super()而且次方法必须先调用，因为子类如果是继承了一个类的情况下，它是没有this的，通过super方法来将父类的this指向子类。
>
> React中的类组件是基于ES6类的规范去实现的，类组件需要继承React.Conponent类，所以一旦有了继承那么必须在constructor中使用super方法才能初始化this，一旦定义了super方法那么就需要写入props参数，这个参数是父组件传递过来的数据。这个props如果不在constructor中通过super方法初始化的情况下，可以在render方法中获取到。但是如果定义了super方法，那么一定要填入props参数，如果不填props参数会报错





#### Context状态树的执行流程？

> context是react提供的一种传递数据的方式。context状态树使用react库中的createContext函数创建，此函数返回两个对象，provider和consumer。
>
> 通过createContext创建context对象，context对象中存有两个函数，provider，consumer。单独导出provider和consumer，默认导出context对象。
>
> 在根组件中包裹provider组件，类组件使用静态属性来接收数据 static createContext = context，函数组件使用<consumer></consumer>接收数据在consumer中有一个函数，函数中有一个参数参数值就是provider的值





#### 什么是高阶组件，有什么作用?

> 高阶组件是一个函数，它接收一个组件并返回一个新的组件。它的作用是：代码复用、渲染劫持、条件渲染





#### react中路由传递参数的方式？

> react-router-dom 分为两个版本 5 和 6 。各个版本传参方式和读取参数的方式不同

**5**

> 三种方式：路径后  ?键=值、路由（/main/:键）传参（路径后/值）、to={{pathname: ' 路由 ',state:{ 键 : 值 } }}
>
> 三种获取参数分别是：props.location.search \ props.match.params \ props.location.state、

**6**

> 三种方式：路径后  ?键=值、路由（/main/:键）传参（路径后/值）、to={{pathname: ' 路由 ',state:{ 键 : 值 } }}
>
> let [query,setQuery]useSreachParams() query.get('键名') 、useParams().键名、useLocation().state.键名





#### react如何捕捉异常

> - js方法   try ··· catch
> - react生命周期 static getDerivedStateFromError   componentDidCatch
> - 事件监听  window.addEventListener('error',(err)=>{·····})



#### 说说React中setState和replaceState的区别？

> setState和replaceState都是用来修改状态的，只不过有一点区别
>
> setState是拿到前一次的state状态和当前的状态合并，最后返回覆盖state状态
>
> replaceState是直接全覆盖state状态，说白了就是替换掉前一次的state状态。
>
> 
>
> 在多数情况下还是使用setState来修改状态较为完善



#### 说说你对fiber架构的理解？解决了什么问题？

> 当一个应用程序**需要并发来处理**多个请求时，那就需要使用**线程来处理**了，而线程的**切换和创建**都是会占用系统内部CPU。
>
> 而fiber架构是在应用程序内部来处理并发请求，在内部创建多个线程以完成请求。这样能在节省系统CPU的情况下高效的、快速的来处理并发



#### 说说你对redux中间件的理解？常用的中间件有哪些？实现原理？

> 理解：用来在action和reducer之间拦截，来实现异步、日志、路由跳转等
>
> 常用：redux-thunk 处理异步请求、redux-promise使action返回一个promise对象、redux-logger来实现日志，每当state修改了就会记录哪里发生了变化
>
> 原理：
>
> ```react
> import {createStore,applyMiddleware} from 'redux';
> 
> import reduxThunk from 'redux-thunk'
> // 使用applymiddleware函数来创建中间件，将中间件作为参数
> const middleware = applyMiddleware(reduxThunk)
> 
> // reducer是处理dispatch任务，initalState初始化state，参数3为中间件
> const store = createStore(reducer, initalState, middleware)
> ```



#### redux中同步action与异步action最大的区别是什么？

> 同步的action是一个**纯函数**，而异步的**通过Middleware拦截**最后通过dispatch**派发同步任务**



#### redux-saga和redux-thunk的区别与使用场景？

> redux-saga和redux-thunk都是redux中间件。
>
> redux-thunk处理简单的http请求，简单容易上手
>
> redux-saga处理一些复杂的异步逻辑例如websocket、任务取消、多任务并发



#### 在使用redux过程中，如何防止定义的action-type的常量重复？

> 1. 在定义acton-type时加上一些特殊的前缀和后缀
> 2. 使用redux-action中的createAction函数来创建action-type的值
>
> ```react
> import {createAction} from ‘redux-actions’ 
> 
> createAction(‘TEST_FIRST’) // 这样定义的使用这种方式生成的action-type名是不会重复的
> ```



#### 知道react里面的createPortal么，说说其使用场景？

> 它是react-dom 中ReactDOM的一个函数
>
> 使用场景：在渲染一个弹框或者对话框时。这样可以避免一些样式的冲突。



#### useEffect的依赖为引用类型如何处理？

> 将依赖项数组分割为多个基本类型依赖项（如数字或字符串），并将其作为 useEffect 的多个参数。例如：useEffect(() => { ... }, [obj.prop1, obj.prop2, arr.length]);
>
> 
>
> 使用 useRef 钩子引用依赖项，然后将其传递给 useEffect。例如：const depRef = useRef(dep); useEffect(() => { ... }, [depRef.current]);
>
> 
>
> 在传递对象时，使用 Object.assign 或 spread 运算符创建新的对象。例如：useEffect(() => { ... }, [Object.assign({}, obj)]);



#### 说说Real diff算法是怎么运作的？

> 1. `Diff`算法是虚拟`DOM`的一个必然结果，它是通过新旧`DOM`的对比，将在不更新页面的情况下，将需要内容局部更新
> 2. `Diff`算法遵循深度优先，同层比较的原则
> 3. 可以使用`key`值，可以更加准确的找到`DOM`节点
>    **`react`中`diff`算法主要遵循三个层级的策略：**
>    **tree层级**
>    **conponent 层级**
>    **element 层级**
>    `tree`层不会做任何修改，如果有不一样，直接删除创建
>    `component`层从父级往子集查找，如果发现不一致，直接删除创建
>    `element`层有key值做比较，如果发现`key`值可以复用的话，就会将位置进行移动，如果没有，则执行删除创建



#### 为什么react元素有一个$$type属性？

> **目的**是为了防止 `XSS 攻击`。因为 `Synbol` 无法被序列化，所以 `React` 可以通过有没有 `$$typeof` 属性来断出当前的 `element` 对象是从数据库来的还是自己生成的。如果没有 `$$typeof` 这个属性，`react` 会拒绝处理该元素。





#### React的props.children使用map函数来遍历会收到异常显示，为什么？应该	如何遍历？

> 如果只有一个子节点时会收到异常显示，因为一个子节点时不是一个数组，不是数组就不能进行使用map函数。
>
> 应该使用**React中的一个函数Children中的toArray()方法**来将单个节点转换成数组类型。转换后就可以遍历了



#### 谈谈你对immutable.js的理解？

> Immutable.js是**Facebook**开发的一个**JavaScript**库，它提供了一系列的数据结构和方法来帮助我们创建**不可变的数据对象**。
>
> Immutable.js提供了几种常见的不可变数据结构，比如**List、Map、Set**等，这些数据结构支持函数式编程范式中的高阶操作，例如map、filter、reduce等用于处理数组的方法，可以让你轻松地对数据进行**增、删、查、改**等一系列操作。
>
> **Immutable.js与React有着天然的结合点**。React推崇“**单向数据流**”，而Immutable.js正好符合这个思路，它可以让我们在React的应用中更加灵活地控制状态树，同时通过使用**shouldComponentUpdate生命周期钩子**可以帮助我们完成对组件更新的优化。



#### 调和阶段setState干了什么？

> 在React中，当调用setState方法时，会触发组件的重新渲染。setState实际上是对组件状态的更新，它将新的状态合并到现有的状态中，并调用相应的生命周期方法和重绘组件。
>
> 在调和阶段，React会根据新的状态和先前的状态进行比较，判断哪些部分需要重新渲染。如果React决定重新渲染组件，它将首先调用shouldComponentUpdate方法检查是否应该进行重新渲染，如果返回false，则跳过渲染过程。如果shouldComponentUpdate返回true，则React将调用render方法进行重新渲染，并根据新的虚拟DOM生成实际的DOM元素，并最终更新到页面中。
>
> 简而言之，setState方法在调和阶段做了以下几件事：
> 1. 更新组件状态；
> 2. 判断是否需要重新渲染组件；
> 3. 如果需要重新渲染，根据新的虚拟DOM生成实际的DOM元素，并最终更新到页面中。

#### react不同版本都有什么变化

- 16版本引入了fiber架构

- 16.3引入了suspense和error Boundaries，可以更好的处理异步请求和错误处理

- 16.3引入了严格模式、新增了部分生命周期代替了旧的生命周期

- 16.8版本引入了函数组件的Hooks

- 17版本对于事件处理做了优化，必须加`on`的前缀

- 18版本使用Render API更好的控制节点

  ```js
  // 18版本
  ReactDOM.createRoot(root).render(<App />);
  // 18版本之前
  ReactDOM.render(<App />, root);
  ```

- 18版本root组件卸载时触发的api改变成了unmount

  ```js
  // React 17
  ReactDOM.unmountComponentAtNode(root);
  
  // React 18
  root.unmount();
  ```

- Fiber架构不同版本的区别

  - 15版本采用的stack example
    16版本采用了fiber example
    数据结构其实就是一个对象，也是一个执行单元
  - **特性**
    - 增量渲染
    - 暂停、终止渲染
    - 不同更新优先级
    - 并发方面新的基础能力
    - 增加了异步任务，调用requestIdleCallback api，会在浏览器空闲的时候运行
    - 会将虚拟dom树也就是diff虚拟dom树，将虚拟dom变成链表格式，会将父节点和兄弟节点和本身形成一个链表格式

# Vue

#### 说说对vue的理解

> vue是一个基于用户页面的JavaScript库
>
> 特点：
>
> 数据驱动  => MVVM双向数据绑定结构
>
> 组件化  => 减少代码复用、提高可维护性
>
> 虚拟DOM
>
> 指令系统 => vue可以通过v-的前缀来实现一些操作
>
> 
>
> 常用的指令有
>
> v-if 条件渲染
>
> v-show 控制隐藏
>
> v-on 绑定事件  @简写
>
> v-for 循环渲染
>
> v-bind 属性绑定   :简写
>
> v-model 双向数据绑定



#### Vue和react的相同和不同

> 相同点：
>
> 组件化操作
>
> 虚拟DOM
>
> 
>
> 不同点：
>
> react数据驱动为MVC单项数据流，vue为MVVM双向数据流
>
> react diff算法是计算差异后统一更新，vue是边计算差异，边更新



#### 响应式原理

- vue2

  主要由三个部分完成，首先是`observer`，这个主要是通过`object.defineProperty`来拦截对象，给每个对象添加**geter和seter**属性；然后通过`watcher`来订阅`observer`的变化，当对象发生改变的时候会通知`compiler`这个编译器；最后通过`compiler`编译器完成视图更新。

- vue3

  和vue2的部分相同，在vue3中`observer`是通过`proxy`拦截对象，可以直接拦截无需遍历。

#### Diff算法原理

> vue中的Diff和虚拟DOM是底层的核心部分
>
> 指针

- vue2

  Diff算法用来做**新旧虚拟DOM树的比较**，最小化的更新视图，而不是全部更新。

  在这个比较过程中Diff算法会**通过指针的方式**，一层一层的比较，并且更新的操作是比较完毕之后就会更新。

- vue3

  和vue2的diff基本一致，不同的是vue3新增静态树提升，这意味着编译时会跳过静态树从而节省性能开销。

  flag标记，无需手动添加key也可以监听遍历的节点

#### Vue中自定义指令的理解，应用场景有哪些？

> 自定义指令分为**全局自定义指令和局部自定义指令**
>
> 全局定义的方式是 
>
> `Vue.directive(‘名称’,`
>
> `{ bind: ()=>{} ,inserted: ()=>{} },update: ()=>{},unbind: ()=>{}`
>
> `)`
>
>  
>
> 局部自定义指令是 在vue文件中 `directives:{ “名称”:{} }`
>
>  
>
> 应用场景：**表单验证、图片懒加载、无限滚动、右键菜单、复制粘贴等** 



#### V2和V3的区别

> 1. v2 的 `optionAPI` 和 v3 的 `Composition API`：
>
>    **Vue3引入了Composition API**，并且支持optionAPI。
>
>    可以更好地组织和复用组件逻辑。
>
>    与Vue2中的Options API那种面向对象式的更灵活，
>
>    Composition API提供了更灵活、可组合和易于测试的方式来编写组件。
>
> 2. TypeScript支持：Vue2对TypeScript的支持并不完全，需要额外的配置和类型声明。而Vue3对TypeScript的支持更加友好，内置了更多的类型声明，并通过改进的响应式系统实现了更好的类型推断。
>
> 3. 源码大小：Vue3的源码相对较小，压缩后的代码比Vue2更小。这意味着在网络传输和加载时间方面，Vue3更加高效。
>
> 4. v2的`Object.defineProperty 和 proxy`
>
> 5. v3中除去了
>
>    `filter`官方推荐使用监听器`watch\watchEffect`来进行一些数据过滤的操作
>
>    `v-once`指令，在v2中绑定事件时只能执行一次
>
>    `v-html`，在v2中用来解析数据中的标签，并渲染相应的标签

#### 对于MVVM的理解

> MVVM是一种软件架构模式，它将应用程序分为三个核心部分：Model（模型）、View（视图）和ViewModel（视图模型）。它的目标是实现数据与视图之间的解耦，使得开发者能够更好地管理和维护代码。
>
> 以下是对MVVM的各个组成部分的简要说明：
>
> 1. Model（模型）：模型代表着应用程序的数据和业务逻辑。它负责处理数据的获取、存储、验证和操作等任务。模型可以是数据库、网络请求返回的数据、或者从其他数据源中获取的数据。
>
> 2. View（视图）：视图是用户界面的可见部分，例如网页上的HTML元素或移动应用程序中的UI控件。视图负责展示数据，并与用户进行交互。在MVVM中，视图应该尽量保持简单和无状态，它主要负责显示来自ViewModel的数据，并将用户的操作转发给ViewModel。
>
> 3. ViewModel（视图模型）：视图模型是连接模型和视图的桥梁。它包含了视图所需展示的数据以及与视图交互的方法和命令。视图模型通过数据绑定机制将模型中的数据与视图中的元素进行绑定，当模型数据改变时，视图会自动更新。
>
> MVVM的关键点在于数据绑定机制，它使得数据的变化能够自动反映到视图中，而不需要手动的DOM操作。这种双向绑定的机制可以减少大量的样板代码，并提高开发效率。
>
> 总结起来，MVVM是一种将视图、模型和视图模型分离的架构模式，通过数据绑定实现视图与模型之间的自动同步。它能够提供更好的代码组织和可维护性，同时也降低了开发的复杂度和耦合度。



#### Vue3中的组合式Api和option Api的区别是什么？

> 1. 组合式API的灵活性：组合式API更加灵活和可组合，可以将相关逻辑划分为多个函数，并根据需要进行组合和复用。相比之下，Options API更加面向对象，需要在同一个选项对象中定义所有的逻辑。
>
> 2. 组合式API的代码组织方式：组合式API通过逻辑相关的功能组件来组织代码，每个功能组件都可以包含自己的状态、计算属性、方法等。而Options API则是通过选项对象来组织代码，不同的逻辑通过不同的选项来定义。
>
> 3. 组合式API的可读性：由于组合式API将相关逻辑划分为函数，每个函数只关注一部分逻辑，因此代码更易于阅读和理解。而Options API则将所有的逻辑放在一个对象中，代码可能会变得冗长和复杂。
>
> 4. 组合式API的类型推断：由于组合式API使用的是函数，Vue3可以更好地推断出函数内部的类型。这使得在使用TypeScript等静态类型检查工具时，能够获得更准确的类型提示和错误检查。
>
> 总体来说，组合式API提供了更灵活、可组合和可读性更高的方式来组织和复用代码。它使得组件的逻辑更加清晰，且能够更好地与TypeScript等静态类型检查工具集成。而Options API则更适合简单的组件或者对面向对象编程更熟悉的开发者。



#### 什么是Vue SSR

> Vue SSR (Server-Side Rendering) 指的是在服务器端渲染Vue应用程序，生成最初的HTML页面，并将其发送到客户端进行进一步的交互。
>
> 传统的Vue应用程序通常在浏览器中运行，使用客户端渲染 (Client-Side Rendering, CSR)。在CSR中，浏览器会下载包含Vue组件的JavaScript文件，并在客户端执行和渲染组件。这种方式可以提供丰富的交互体验，但对于SEO（搜索引擎优化）和首次加载性能等方面存在一些挑战。
>
> 相比之下，Vue SSR通过在服务器上预先渲染Vue组件，生成完整的HTML响应。当浏览器请求页面时，服务器直接返回预渲染好的HTML，而无需等待JavaScript文件的加载和执行。这样可以使搜索引擎更好地索引页面内容，并提供更快的首次加载时间，特别是对于慢速网络或低性能设备来说。
>
> Vue SSR的工作原理如下：
>
> 1. 服务器端接收到HTTP请求，并根据路由匹配相应的Vue组件。
>
> 2. 服务器创建一个Vue实例，并调用组件的生命周期钩子函数进行数据获取和初始化。
>
> 3. 当所有数据准备就绪后，服务器使用Vue的渲染器将Vue组件渲染成完整的HTML字符串。
>
> 4. 服务器将渲染好的HTML字符串作为响应返回给客户端浏览器。
>
> 5. 客户端浏览器接收到HTML响应，并加载JavaScript文件。一旦Vue实例在浏览器中激活，它会接管静态HTML，并将其转换为动态交互的Vue应用程序。
>
> Vue SSR需要一些特定的配置和服务器环境来支持，例如使用Node.js来运行服务器端代码。同时，由于涉及到前后端渲染的共享逻辑，开发过程中需要注意处理好数据的同步和一致性。
>
> 总结来说，Vue SSR是一种通过在服务器上进行预渲染的方式，提供更好的SEO和首次加载性能的解决方案。它在服务器端渲染Vue组件，并将预渲染好的HTML响应发送到客户端浏览器，以实现更好的用户体验和搜索引擎优化。



#### vue路由的钩子函数有哪些

> Vue路由提供了一系列的导航守卫，也称为钩子函数，用于在路由切换过程中执行特定的逻辑。以下是Vue路由的常用钩子函数：
>
> 1. beforeEach(to, from, next)：全局前置守卫，每次路由切换之前都会被调用，可以用于进行全局的身份验证或权限检查等。
> 2. afterEach(to, from)：全局后置守卫，每次路由切换之后都会被调用，没有 `next` 函数，无法改变导航。
> 3. beforeEnter(to, from, next)：路由独享的前置守卫，在单个路由配置中使用，用于对该路由进行特定的身份验证或权限检查等。
> 4. beforeRouteEnter(to, from, next)：组件内的守卫，当路由将要进入某个组件时被调用，允许访问组件实例，但此时还不能访问组件的 `this` 对象。
> 5. beforeRouteUpdate(to, from, next)：组件内的守卫，当路由参数发生变化，但是该组件被复用时调用，允许访问组件实例，并可以通过比较新旧路由参数来做相应的操作。
> 6. beforeRouteLeave(to, from, next)：组件内的守卫，当路由将要离开组件时调用，允许访问组件实例，可以在用户离开当前页面前进行一些确认操作。



#### Vue的路由实现：hash模式 和 history模式原理

> Vue的路由实现包括两种模式：hash模式和history模式。
>
> 1. Hash模式：
>    在Hash模式下，URL中会带有一个特殊字符“#”，后面跟着路由路径。当浏览器向服务器发送请求时，不会包含这部分hash值。浏览器通过监听`hashchange`事件来感知URL的变化，并根据hash值来切换不同的路由组件。
>
> 例如，对于URL `http://example.com/#/home`，浏览器只会将`http://example.com/`发送给服务器，而`#/home`部分则由浏览器自身处理。
>
> 2. History模式：
>    在History模式下，URL没有特殊字符，通过HTML5 History API来管理URL的变化。它使用了`pushState()`和`replaceState()`方法来添加和修改浏览器历史记录条目，并通过`popstate`事件来感知URL的变化。

#### V3的设计目标，做了哪些优化？

> V3的设计目标是，更小、更快、更完善的ts环境
>
> 优化：
>
> 1. 编译优化
>
>    优化diff算法，v3中的diff新增flag标记。当dom树发生变化时比较flag标记
>
> 2. 静态提升
>
>    v3将不参与更改的元素，会做静态提升，只会创建一次。下次渲染直接复用
>
>    例如
>
>    ```vue
>    <template>
>    	<div>你好</div>
>    	<p>{{ text }}</p>
>       
>    </template>
>    // 这里div标签就属于不参与更改的元素，v3会做静态提升，将这个node节点保存到render外面。
>    // 当下次更新视图时，div这个纯html就会在缓存中复用
>    ```
>
> 3. 事件监听缓存
>
> 4. SSR优化，将多个静态内容，通过createStaticVNode方法创建。，这个方法会将静态内容innerHtml到页面中

#### V3中的proxy和v2中的object.defineProperty的区别，有哪些优势

> object.defineProperty和proxy都是用来拦截对象，对原对象进行一些增删改查操作
>
> - object.defineProperty
>
>   它接收一个对象返回一个新的对象，并且它有存取描述符和数据描述符。
>
>   在v2中主要使用了存取描述符，通过get来获取对象的数据，通过set方法来修改对象的数据。
>
>   v2中新添加了delete方法用于销毁对象的属性
>
> - proxy
>
>   proxy也是es6新增的一大特性
>
>   它对比object.defineProperty更强大。首先是拦截方式
>
>   object.defineProperty只能遍历对象拦截。
>
>   proxy可以直接拦截整个对象，并复用对象当中的所有方法。



#### 说说SPA开发模式的首次加载页面慢的原因，怎么解决

> 原因是：
>
> 网络原因、资源文件较大
>
> 解决方案：
>
> 静态资源的本地缓存、将一些UI组件按需加载



#### 说说Teleport的理解

> v3新增的特性，在v2中要实现一个弹出框可能会影响布局。
> 在v3中新增了teleport组件，它有一个to属性可以将组件中的内容，发送到body标签中，从而不影响布局
>
> ```
> <teleport to='body'>
> 	<div class='model'>
> 		...
> 		...
> 		...
> 	</div>
> </teleport>
> ```
>



#### Vue 3 的 Fragments 是什么？

> Fragments 是 Vue 3 中的一项新特性，它允许我们在模板中返回多个根元素。这可以让我们更灵活地组织模板结构。
>
> 在 Vue 2 中，每个组件的模板都必须有一个根元素。这意味着，如果我们想要在模板中返回多个元素，我们必须将它们包裹在一个根元素内部。
>
> 而在 Vue 3 中，我们可以使用 Fragments 来返回多个根元素。这样，我们就不需要再使用一个额外的根元素来包裹多个元素了。
>
> 例如：
>
> ```vue
> <template>
>   <div>Item 1</div>
>   <div>Item 2</div>
> </template>
> ```



#### Vue 3 的 Suspense 是什么？

> Suspense 是 Vue 3 中的一项新特性，它允许我们在组件的异步依赖加载完成之前显示一个 fallback 内容。这可以让我们更好地处理异步数据加载的情况。
>
> 在 Vue 2 中，我们通常需要在组件内部使用一个状态变量来跟踪数据是否加载完成，并根据这个状态变量来决定是否显示加载中的提示。
>
> 而在 Vue 3 中，我们可以使用 Suspense 来简化这个过程。我们只需要将组件包裹在一个 Suspense 元素中，并为 Suspense 元素提供一个 fallback 插槽，用来指定在异步依赖加载完成之前要显示的内容。当异步依赖加载完成后，Suspense 会自动切换到默认插槽中的内容。
>
> ```vue
> <template>
> <Suspense>
>  <template #default>
>    <AsyncData />
>  </template>
>  <template #fallback>
>    <div>Loading...</div>
>  </template>
> </Suspense>
> </template>
> 
> <script>
> import AsyncData from './AsyncData.vue';
> export default {
> components: {
>  AsyncData,
> },
> };
> </script>
> ```
>
> 在这个例子中，我们使用了一个 **Suspense** 元素来包裹 `AsyncData` 组件。在 `AsyncData` 组件的异步依赖**加载完成之前**，Suspense 会显示 **fallback 插槽中的内容（即“Loading…”）。当异步依赖加载完成后，Suspense 会自动切换到默认插槽中的内容（即 `AsyncData` 组件）。**



#### 严格模式

> 严格模式下的一些限制和检查包括：
>
> 1. 禁止直接修改组件实例的根数据（data）：在严格模式下，**只有组件的方法（methods）才能修改组件实例的根数据**。如果我们在计算属性（**computed**）或侦听器（**watcher**）中试图直接修改根数据，Vue会发**出警**告。
> 2. 侦测不到的异步更新警告：在严格模式下，如果我们在异步更新的回调中修改了响应式数据（例如setTimeout或事件处理程序），Vue会发出警告。这是因为Vue无法在异步更新中检测到数据的变化。
> 3. 更严格的模板编译：在严格模式下，Vue的模板编译会更加严格，一些不规范的写法会被禁止。例如，禁止在模板中使用未定义的变量，禁止使用无效的表达式等。
>
> 通过开启严格模式，我们可以更早地发现代码中的问题，并且遵循Vue的最佳实践和规范，以提高代码的可维护性和可靠性。我们可以通过在**Vue实例的选项中设置`strict: true`来开启严格模式**。默认情况下，严格模式是禁用的。



#### v-if和v-for哪个优先级高

> - v2中v-for优先级高
> - v3中v-if优先级高



#### watch和watchEffect的区别

> watch用来监听指定的数据。当指定的数据变化时后做一些操作
>
> watchEffect是自动监听，在watchEffect中包含的数据都会被监听到



#### v3中的TreeShaking的特性

> TreeShaking是v3的新特性。
>
> 它基于ES6的模块化规范，通过清除多余代码的方式来提高打包速度。
>
> 保证代码能够正常运行的前提下，清除多余的无用代码。
>
> 优点：
>
> 减少打包体积
>
> 加快打包速度



#### vue中常用的修饰符

> - 表单修饰符
>   - number转换数字类型
>   - trim清除两端空格
>   - lazy在光标离开时触发
> - 事件修饰符
>   - stop阻止事件冒泡
>   - prevent阻止默认事件
>   - self只在自身触发
>   - once触发一次
>   - native使根组件的事件定义成子组件的原生事件
> - 鼠标修饰符
>   - left左键
>   - right右键
>   - middle中间
> - 键盘修饰符
>   - 支持keycode码
>   - 支持键盘上的一些功能键等
>   - enter
>   - delete

#### 3种Vue3添加公共方法并使用

##### 第一种：使用 app.config.globalProperties 添加

```js
import { createApp } from 'vue'
import axios from 'axios'
const app = createApp({  
	created() {    
        console.log(this.$axios)  
    }
})
app.config.globalProperties.$axios = axiosapp.mount('#root')
```

在setup中访问（setup中没有this）

```js
<script setup>
import {getCurrentInstance} from 'vue'
const { proxy } = getCurrentInstance();//获取公用方法proxy.$axios，或者use中方法
const {$axios}=proxy
console.log($axios)
</script>
```

##### 第二种：使用 app.mixin 添加

```js
import { createApp } from 'vue'
import axios from 'axios'
const app = createApp({  
    created() {    
        console.log(this.$axios)  
    }
})
app.mixin({  
    methods: {    
        $axios: axios  
    }
})
app.mount('#root')
```

##### 第三种：采用 provide, inject 方法

需要注意的是这种方法需要组建 inject 注入进组件才能使用。

```js
import { createApp } from 'vue'
import axios from 'axios'
const app = createApp({  
    inject: ['$axios'],  
    created() {    
        console.log(this.$axios)  
    }
})
app.provide('$axios', axios)
app.mount('#root')
```



# webpack

#### 说说如何借助webpack来优化打包速度 == 前端性能？

> 代码分隔（实现按需加载）、压缩代码（减少文件大小）、静态资源处理（file-loader和url-loader）、懒加载和按需加载
>
> 1. 使用最新版的webpack，最新版的会规避一些隐性的问题
> 2. 使用合适的模式，例如开发模式、生产模式
> 3. 使用include和exclude配置项，只解析必要的文件
> 4. 使用alias配置项，将长路径优化为段路径
> 5. 使用多进程和多线程的方式打包
> 6. 使用cache配置项，持久化缓存，避免重复打包



#### 说说webpack中常见的loader？解决了什么问题？

> babel-loader：将ES6/ES7/JSX装换为ES5语法，以便浏览器识别
>
> css-loader：解析CSS文件，将css文件装换为模块以便JavaScript使用
>
> style-loader：用于将CSS样式注入DOM中
>
> file-loader：用于图片、静态文件，转换为URL
>
> url-loader：将文件转换为base64格式
>
> sass-loader：用于将sass/scss装换为CSS
>
> less-loader：用于将LESS装换为CSS



#### 说说webpack中代码分割如何实现？

> 使用 **entry** 配置，根据**入口**进行代码拆分。
>
> 配置 **splitChunks** 插件，根据不同的策略、依据模块之间的关系将**公共部分抽离成单一文件**，如 vendor 外部依赖、公共代码等。
>
> 在开发中可以根据实际需求选择不同的方案，以达到更高的性能和优化效果。同时，为了避免缓存问题，可以在打包时加上输出文件的 chunk hash 值。



#### 说说你对webpack的理解？plugin和loader有什么区别？

> Webpack是一个现代化的前端构建工具，它主要用于将多个模块打包成最终的静态资源文件，如JavaScript、CSS和图片等。Webpack提供了强大的模块化处理能力和丰富的插件系统，使得前端开发更加高效和灵活。
>
> 以下是对Webpack的几个关键概念的解释：
>
> 1. Entry（入口）：Webpack从指定的入口文件开始构建应用程序的依赖图。通常情况下，一个入口文件对应着一个或多个模块。
>
> 2. Output（输出）：Webpack将所有的依赖模块打包成一个或多个输出文件，用于部署到生产环境。可以指定输出文件的名称、路径和格式。
>
> 3. Loader（加载器）：Loader负责将非JavaScript模块转换为Webpack可识别的模块。它可以处理各种类型的文件，例如将CSS转换为JavaScript模块，或者在构建过程中对图片进行压缩和优化。
>
> 4. Plugin（插件）：Plugin是Webpack的核心功能扩展机制，用于执行各种自定义任务和优化。插件可以完成一系列的构建任务，例如代码压缩、文件拷贝、环境变量注入等。与Loader不同，插件作用于整个构建过程而不仅仅针对单个模块。
>
> Loader是处理模块级别的转换工具，Plugin是扩展Webpack功能的工具，用于执行整个构建过程中的任务和优化。在Webpack配置中，Loader通过module.rules配置，而Plugin通过plugins配置。两者合作使用可以实现更高效、灵活的前端构建流程。

#### 说说webpack中常见的Plugin？解决了什么问题？

> 1. HtmlWebpackPlugin：用于生成HTML文件，并自动注入打包后的资源（如CSS、JS）到HTML中。
> 2. MiniCssExtractPlugin：将CSS从打包的JS文件中提取出来，生成独立的CSS文件，可以实现样式的异步加载和缓存优化。
> 3. DefinePlugin：在打包过程中，替换代码中的全局常量，比如定义环境变量等。
> 4. ProvidePlugin：自动加载模块，通过全局变量的方式，在每个模块中都不需要显式地引入。
> 5. CopyWebpackPlugin：将指定的文件或文件夹复制到构建目录中，常用于拷贝静态资源文件。
> 6. CleanWebpackPlugin：在每次构建前，清理指定的输出文件夹，确保每次构建前都是一个干净的状态。
> 7. HotModuleReplacementPlugin：启用热模块替换（HMR），在开发过程中无需刷新整个页面，即可实时预览修改。
> 8. ExtractTextWebpackPlugin：将CSS代码从JS文件中提取出来，并以独立的CSS文件进行引用，适用于Webpack 3及以下版本。
> 9. UglifyJsPlugin：对JS代码进行压缩和混淆，减小文件体积，加快加载速度。
> 10. BundleAnalyzerPlugin：可视化分析项目中各个模块的大小和依赖关系，帮助优化项目结构和性能。

#### `SourceMap`

在我们使用webpack打包之后，如果在浏览器中运行，报错的位置会**提示打包之后的js文件**

- sourceMap的作用

  通过在`webpack.config.js`中配置`devtool:'cheap-module-source-map' || 'source-map'`不同的环境中配置在开发环境配置第一个，生产环境配置第二个。

  配置完之后，在运行webpack之后在浏览器中运行，会在控制台显示打包之前报错代码的位置。

  它会在我们的项目中新建`XXX.map`的文件，这个文件将打包之前和之后的模块相互关联。

# JavaScript



### JavaScript中的数据类型？存储上的区别？

1. 基本数据类型
2. 引用数据类型

##### 基本数据类型有

> 1. Number
> 2. String
> 3. Boolean
> 4. Null
> 5. undefind
> 6. symbol

##### 引用数据类型有

> function
>
> Array
>
> Object
>
> Set
>
> Map

##### 存储上的区别

> 基本数据类型的值和内存地址都存在栈中。若直接将一个基本数据类型赋值给一个变量这个赋值是深拷贝，它会生成新的值存储在栈中。
>
> 引用数据类型的变量存储在栈中，内存地址存储在堆中。所以它存在一个深浅拷贝的问题，当我们直接赋值时是浅拷贝。
>
> 浅拷贝的问题是：当我们修改赋值之后的变量时，其实修改的是内存地址的值。导致的问题就是在一处修改，其他绑定这个内存地址的变量都会修改。
>
> 深拷贝的实现：通过JSON方法，它的缺点是不能识别undefined、function等；通过ES6新增的...扩展运算符

### typeof 与 instanceof 区别

> - `typeof`可以判断的数据类型有`number、string、Boolean、null、undefined、symbol、object`。
>
>   在判断`基本数据类型`时可以返回它的`数据类型`，判断`object、array、Map、Set`引用数据类型时它只能返回`object`数据类型
>
>   ```js
>   console.log(typeof 42); // 输出 "number"
>   console.log(typeof "Hello"); // 输出 "string"
>   console.log(typeof true); // 输出 "boolean"
>   console.log(typeof undefined); // 输出 "undefined"
>                           
>   console.log(typeof null); // 输出 "object"（注意：这是一个历史遗留问题）
>   console.log(typeof [1, 2, 3]); // 输出 "object"
>   console.log(typeof { name: "John", age: 30 }); // 输出 "object"
>                           
>   console.log(typeof function () {}); // 输出 "function"
>   ```
>
> 
>
> - `instanceof`可以判断任意的数据类型，它判断的方式是通过数据的构造函数，通过`原型链`向上寻找是哪个类构建出来的数据类型，最后返回true或者false。使用方式是`'string' instanceof String`判断`'string'字符串是否是String的实例`
>
>   ```js
>   console.log(42 instanceof Number); // 输出 false（42 是一个原始值，不是 Number 的实例）
>   console.log("Hello" instanceof String); // 输出 false（"Hello" 是一个原始值，不是 String 的实例）
>   console.log(true instanceof Boolean); // 输出 false（true 是一个原始值，不是 Boolean 的实例）
>   console.log(undefined instanceof Object); // 输出 false（undefined 是一个原始值，不是 Object 的实例）
>   console.log(null instanceof Object); // 输出 false（null 不是 Object 的实例）
>   console.log([1, 2, 3] instanceof Array); // 输出 true
>   console.log({ name: "John", age: 30 } instanceof Object); // 输出 true
>   console.log(function () {} instanceof Function); // 输出 true
>   
>   ```
>
> - `constructor`
>
>   每个变量的原型都有`constructor`属性，这个属性的值是构造函数名称。它的缺陷是`constructor`可以修改，当我们手动修改了`constructor`属性之后会造成数据顺乱
>
>   ```js
>   console.log(42.constructor === Number); // 输出 true
>   console.log("Hello".constructor === String); // 输出 true
>   console.log(true.constructor === Boolean); // 输出 true
>   console.log(undefined.constructor === undefined); // 输出 false（undefined 没有 constructor 属性）
>   console.log(null.constructor === null); // 输出 false（null 没有 constructor 属性）
>   console.log([1, 2, 3].constructor === Array); // 输出 true
>   console.log({ name: "John", age: 30 }.constructor === Object); // 输出 true
>   console.log((function () {}).constructor === Function); // 输出 true
>   ```
>
> 
>
> - `Object.prototype.toString.call(object)`
>
>   是`Object`原型上的一个方法，表示返回一个表示对象以及数据类型的字符串
>
>   ```js
>   console.log(Object.prototype.toString.call(42)); // 输出 "[object Number]"
>   console.log(Object.prototype.toString.call("Hello")); // 输出 "[object String]"
>   console.log(Object.prototype.toString.call(true)); // 输出 "[object Boolean]"
>   console.log(Object.prototype.toString.call(undefined)); // 输出 "[object Undefined]"
>   console.log(Object.prototype.toString.call(null)); // 输出 "[object Null]"
>   console.log(Object.prototype.toString.call([1, 2, 3])); // 输出 "[object Array]"
>   console.log(Object.prototype.toString.call({ name: "John", age: 30 })); // 输出 "[object Object]"
>   console.log(Object.prototype.toString.call(function () {})); // 输出 "[object Function]"
>                           
>   ```
>
> 

### 前端跨域解决方案及其实现方式？

> 在前端开发中，跨域是指在浏览器上运行的 JavaScript 代码试图访问不同域名、不同端口或不同协议的资源时遇到的限制。浏览器的同源策略限制了这种跨域访问，为了解决跨域问题，可以采用以下几种常见的解决方案：
>
> **JSONP（JSON with Padding）：**通过动态创建<script>标签，将跨域请求数据作为回调函数的参数传递，服务器将数据包装在回调函数中返回。JSONP 只适用于 GET 请求。
>
> **CORS**（跨域资源共享）：在服务器端进行配置，通过设置响应头部信息来授权不同域的前端页面进行跨域访问。通过在服务器端设置Access-Control-Allow-Origin等相关头部信息，允许特定域名的请求访问资源。
>
> **代理服务器**：在同源策略下，通过在同域名下创建一个代理服务器，将跨域请求转发到目标服务器，并将目标服务器的响应返回给前端。前端代码通过访问代理服务器来间接获取跨域资源，避免了直接跨域请求。
>
> **WebSocket**：使用 WebSocket 协议进行双向通信，WebSocket 不受同源策略限制，因此可以实现跨域通信。



### javascript 代码中的"use strict";是什么意思

> "use strict" 是 JavaScript 中的一个指令（directive），用于启用严格模式（strict mode）。在使用该指令后，JavaScript 解释器将会以严格模式来解析和执行代码，从而使得代码的执行更加严格、安全，并且提供更好的错误检查。
>
> "use strict" 的作用包括：
>
> 1. **消除隐式全局变量**：
>    
>    - 在严格模式下，不允许未声明的变量被引用，否则会抛出 ReferenceError 错误。
>
>    - 在非严格模式下，未声明的变量会被隐式地创建为全局变量，可能导致意外的变量污染和错误。
>    
>      ```js
>      function fn(){
>          a = 10;
>      }
>                                                             
>      function fn(){
>          "use strict"
>          a = 10; // 抛出错误
>      }
>      ```
>    
>      
>    
> 2. **禁止删除变量**：
>    
>    - 在严格模式下，使用 `delete` 操作符删除变量会导致语法错误。
>
>    - 在非严格模式下，使用 `delete` 操作符删除变量不会抛出错误，但可能导致意外的结果。
>    
>      ```js
>      // 非严格模式下，删除变量不会报错
>      var x = 10;
>      console.log(x); // Output: 10
>      delete x;
>      console.log(x); // Output: undefined
>                                                             
>      // 严格模式下，删除变量会报错
>      'use strict';
>      var y = 20;
>      console.log(y); // Output: 20
>      delete y; // TypeError: Cannot delete property 'y' of [object Object]
>      console.log(y); // Output: 20
>                                                             
>      ```
>    
>      
>    
> 3. **禁止使用保留字作为变量名**：
>    
>    - 在严格模式下，使用 ECMAScript 保留字（如 `eval`、`arguments`）作为变量名会导致语法错误。
>    - 在非严格模式下，使用保留字作为变量名是合法的，但可能会导致意外的问题。
>    
> 4. **禁止对只读属性赋值**：
>    
>    - 在严格模式下，对只读属性（如内建对象的属性）赋值会抛出 TypeError 错误。
>    - 在非严格模式下，对只读属性赋值不会抛出错误，但赋值操作会被忽略。
>    
> 5. **限制函数内的 this 值**：
>    
>    - 在严格模式下，函数内部的 `this` 值未定义时，它将保持为 `undefined`，而不是默认绑定到全局对象。
>    - 在非严格模式下，函数内部的未定义 `this` 值将绑定到全局对象。
>
> 使用严格模式的好处是可以提前捕获代码中的潜在问题，防止一些常见的错误，并鼓励编写更健壮、规范的代码。通过在代码的开头添加 "use strict" 指令，可以启用严格模式，使代码在更严格的环境中执行。



### JavaScript如何实现函数缓存？函数缓存有哪些应用场景？

> 在JavaScript中，要实现函数的缓存，可以通过检查对象对应的键是否存在，或者Map、WeakMap可以实现缓存。主要通过一个缓存函数接收一个**要缓存**的函数，缓存函数返回一个匿名函数通过**执行函数**来决定参数，在缓存函数返回匿名函数之前定义好用于缓存的对象或者Map、WeakMap，通过一些判断来决定接收的函数是否执行
>
> ```js
> // 缓存对象，放在最外层是为了清理缓存时可以访问到
> const cache = {};
> function memoize(func) {// 缓存函数
>     
>     return (...args)=>{
>     	const key = JSON.stringify(args)// 参数作为键名
>         if(cache[key]){// 判断键对应的值是否存在
>            	return cache[key]// 存在返回键对应的值
>         }
>         const result = func(args)
>         cache[key] = result
>         return result // 不存在，对指定的键添加值，最后返回函数的执行结果
>     }
> }
> function fn(num){// 要缓存的函数
>     // 
>     return num
> }
> 
> const testFun = memoize(fn)
> testFun(1)
> // 这里testFun的参数传入了memoize返回的匿名函数中
> 
> ```
>
> **提高性能、减少重复计算的函数、减少向后端请求的次数**

### 说说你对尾递归的理解，有哪些应用场景？

> 尾递归是指递归函数在递归调用时，最后一个操作是函数本身的调用，并且该调用的返回值直接作为当前函数的返回值。换句话说，尾递归是指递归函数在最后一步操作时不需要保存任何中间结果或状态。
>
> 在理解尾递归之前，先了解递归调用的工作原理。当一个函数调用自身时，会创建一个新的函数调用帧（function call frame）并将其压入调用栈（call stack），同时将当前函数的局部变量和状态保存在该调用帧中。每次递归调用都会创建一个新的调用帧，当递归深度增加时，调用栈中的调用帧也会增多，占用更多的内存。
>
> 尾递归的特点是在递归调用时，不需要保存额外的状态或变量，并且递归调用是当前函数的最后一个操作。这样的尾递归可以优化为迭代形式，从而避免调用栈的过度增长，提高程序的性能和效率。
>
> 尾递归在以下场景中特别有用：
>
> 1. 阶乘计算：计算一个数的阶乘可以使用尾递归来实现，例如计算n的阶乘可以定义一个函数`factorial(n, acc)`，其中`n`表示当前的数字，`acc`表示累积的结果。每次递归调用时，更新`acc`的值，并将`n`减1，直到`n`为0时返回累积的结果。这种尾递归形式可以有效地计算大数的阶乘而不会引发栈溢出。
>
> 2. 斐波那契数列：斐波那契数列也可以使用尾递归来实现，通过传递前两个数的值和一个累积值作为参数，在每次递归调用时更新这些参数，直到达到指定的终止条件。这样可以避免递归深度过大而导致的性能问题。
>
> 3. 遍历树结构：对于树结构的遍历，尤其是深度优先搜索（DFS）算法，尾递归可以帮助减少内存消耗。通过尾递归实现深度优先搜索，可以避免使用显式的堆栈结构，而是利用函数调用栈来保存状态，从而减少内存的使用。
>
> 需要注意的是，并非所有的递归函数都可以被优化为尾递归形式。只有满足尾递归的条件（递归调用是最后一个操作，不需要保存额外的状态）才能进行优化。

### 说说JavaScript数字精度丢失的问题，如何解决？

> 在 JavaScript 中，存在数字精度丢失的问题，这是因为 JavaScript 使用 IEEE 754 标准的双精度浮点数表示数字。由于使用有限的二进制位数来表示浮点数，某些十进制数无法精确表示，从而导致精度丢失。
>
> 例如，计算 0.1 + 0.2 的结果在 JavaScript 中会得到 0.30000000000000004 而不是预期的 0.3。这是因为 0.1 和 0.2 在二进制表示中是无限循环的，而双精度浮点数只能表示有限位数的二进制。
>
> 为了解决 JavaScript 中数字精度丢失的问题，可以采取以下方法：
>
> 1. 使用整数运算：尽量避免使用浮点数进行计算，而是将数字转换为整数进行计算，然后再转回浮点数。例如，可以将小数转换为整数进行计算，再将结果除以相应的倍数。
>
> 2. 使用高精度库：JavaScript 中有一些高精度计算的库，如 BigNumber.js 和 decimal.js，它们提供了更高精度的数值计算功能。这些库通过自定义数据结构和算法来实现高精度计算，可以避免浮点数精度丢失的问题。
>
> 3. 使用toFixed()方法：toFixed() 方法可以将浮点数转换为指定精度的字符串表示形式。通过设置适当的小数位数，可以在显示数字时避免精度丢失。例如，使用 `(0.1 + 0.2).toFixed(1)` 可以得到正确的结果 "0.3"。
>
> 4. 比较时使用误差范围：在比较浮点数时，避免使用精确相等（`===`）运算符，而是使用一个误差范围来比较两个浮点数之间的差异。例如，判断两个浮点数是否相等可以使用 `Math.abs(a - b) < epsilon`，其中 epsilon 是一个足够小的数，表示允许的误差范围。
>
> 需要根据具体的应用场景选择合适的解决方案。对于一般的计算和显示需求，使用合适的精度处理方法可以减少数字精度丢失带来的问题。对于需要高精度计算的场景，可以考虑使用专门的高精度计算库来处理数字。



### 说说你对事件循环event loop的理解？

> 任务在主线程不断进栈出栈的一个循环过程。
> 在JavaScript中，所有的任务都可以分为
> 同步任务：立即执行的任务，同步任务一般会直接进入到主线程中执行
> 异步任务：异步执行的任务，比如ajax网络请求，setTimeout定时函数等
> 异步任务还可以**细分为微任务与宏任务**
> 微任务一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前
> 宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合



### 事件代理

> 事件代理是一种优化性能的方式。通过事件冒泡的机制，减少事件绑定的次数
>
> ```html
> <ul id='box'>
>     <li></li>
>     <li></li>
>     <li></li>
> </ul>
> 
> <script>
>     let box = document.getElementbyId('box')
>     box.addEventListener('click',(event)=>{
>         if(event.target.tagName === 'LI'){
>             // 判断事件冒泡的实践对象的标签名称
>         }
>     })
> </script>
> ```
>
> 



### js中常建的DOM操作

> 1. 获取元素：
>    - `getElementById(id)`：通过元素的 id 属性获取单个元素。
>    - `getElementsByClassName(className)`：通过元素的类名获取一组元素。
>    - `getElementsByTagName(tagName)`：通过元素的标签名获取一组元素。
>    - `querySelector(selector)`：通过 CSS 选择器获取匹配的第一个元素。
>    - `querySelectorAll(selector)`：通过 CSS 选择器获取匹配的所有元素。
> 2. 操作元素内容：
>    - `textContent`：获取或设置元素的文本内容。
>    - `innerHTML`：获取或设置元素的 HTML 内容。
>    - `innerText`：获取或设置元素的可见文本内容。
> 3. 操作元素属性：
>    - `getAttribute(name)`：获取元素的指定属性值。
>    - `setAttribute(name, value)`：设置元素的指定属性值。
>    - `removeAttribute(name)`：移除元素的指定属性。
>    - `classList`：操作元素的类名，如添加、移除、切换类名。
> 4. 操作元素样式：
>    - `style`：访问和修改元素的内联样式属性。
>    - `classList`：操作元素的类名，如添加、移除、切换类名。
> 5. 创建、插入和删除元素：
>    - `createElement(tagName)`：创建一个指定标签名的新元素。
>    - `appendChild(node)`：将一个节点作为子节点添加到另一个节点的末尾。
>    - `insertBefore(newNode, referenceNode)`：将一个节点插入到另一个节点之前。
>    - `removeChild(node)`：从父节点中移除一个子节点。
> 6. 事件操作：
>    - `addEventListener(event, listener)`：为元素添加事件监听器。
>    - `removeEventListener(event, listener)`：移除元素的事件监听器。



### 对BOM对象的理解？

> 1. BOM 的理解：
>    - BOM 是构成浏览器的一部分，是 JavaScript 在浏览器环境中的扩展，它提供了访问和操作浏览器窗口、浏览器本身以及与浏览器相关的功能和信息的能力。
>    - BOM 并没有标准的规范，不同浏览器对 BOM 的实现可能会有差异。
> 2. 常见的 BOM 对象：
>    - `window` 对象：代表浏览器窗口或框架，它是 BOM 的核心对象，也是全局对象。
>    - `navigator` 对象：提供关于浏览器的信息，如浏览器的名称、版本、用户代理等。
>    - `location` 对象：提供对当前加载的文档的信息和控制浏览器重定向到新的 URL。
>    - `history` 对象：提供对浏览器历史记录的访问和控制，可以在历史记录中前进或后退导航。
>    - `screen` 对象：提供关于用户屏幕的信息，如屏幕宽度、高度、像素密度等。
>    - `document` 对象：虽然属于 DOM（文档对象模型），但它也是 BOM 的一部分，用于操作文档内容。
>
> 除了上述常见的 BOM 对象，还有其他一些对象和功能，如 `localStorage` 和 `sessionStorage`（用于在浏览器中存储数据）、`XMLHttpRequest`（用于发送异步请求）等。每个浏览器可能还会提供一些特定的 BOM 扩展，具体取决于浏览器厂商和浏览器版本。



### 作用域链的理解？

> 他是JavaScript中用于查找变量的机制，由多个作用域对象按照嵌套关系形成的链式结构。
>
> **作用域链的构成**：每个函数都会生成自己的作用域，其作用域中声明变量或者其他函数。
>
> **变量查找的过程**：在一个函数中读取一个变量时，JavaScript引擎会先在当前作用域下查找，如果没有会向上一级的作用域查找。直到找到window对象还是没有找到则抛出错误
>
> **讲解闭包的概念**



### 原型链和原型的理解？

`实例.__proto__ === 原型`

`构造函数.prototype === 原型`

`原型.constructor === 构造函数` 

- 如果实例的`__proto__`没有值就会向它的构造函数中查找，如果构造函数没有`__proto__`就会在它的原型上查找，如果还是没有`__proto__`就会输出`undefined`
  这种一直向上级查找的过程就称为原型链

### 继承

- 组合式继承

  ```js
  function Parent(value){
      this.value = value
      this.foo = ()=>{
          // Parent中的方法
      }
  }
  function Child(value){
      // 这里将Parent的this指向Child作用域。
      // 在Parent中的所有方法和属性都会继承到Child中
      Parent.call(this, value)
  }
  
  ```

  

### Javascript本地存储的方式有哪些？区别及应用场景？

JavaScript 提供了几种本地存储的方式，每种方式都有其特点和适用场景。以下是常见的 JavaScript 本地存储方式及其区别和应用场景：

#### Cookie：

- Cookie 是一小段文本信息，由服务器发送到浏览器，并存储在浏览器的本地文件中。
- 区别：
  - 存储容量较小（通常为 4KB）。
  - 可设置过期时间，可以在指定时间后自动过期。
  - 在每次请求时会自动发送到服务器。
- 应用场景：
  - 存储少量用户数据，如用户登录状态、用户偏好设置等。
  - 与服务器进行会话管理。
  - 跨页面数据传递。

#### Web Storage：

- Web Storage 是 HTML5 引入的一种本地存储机制，提供了在浏览器中存储键值对的能力。
- 区别：
  - `localStorage`：存储的数据在浏览器关闭后仍然保留，除非主动删除或过期。
  - `sessionStorage`：存储的数据仅在当前会话期间有效，浏览器关闭后会自动清除。
  - 存储容量通常为 5MB 或更大。
  - 仅在客户端使用，不会自动发送到服务器。
- 应用场景：
  - 持久化保存用户偏好设置、本地缓存等数据。
  - 会话期间共享数据。
  - 跨页面数据传递。

#### IndexedDB：

- IndexedDB 是一种高级的本地数据库，提供了类似关系型数据库的功能，用于存储结构化的数据。
- 区别：
  - 可以存储大量数据，容量更大。
  - 提供事务支持，支持索引和查询操作。
  - 异步 API，操作复杂一些。
- 应用场景：
  - 存储大量结构化数据，如离线应用程序、缓存数据等。
  - 复杂的数据查询和索引需求。

#### FileSystem API：

- FileSystem API 允许 Web 应用程序在用户的本地文件系统中创建、读取、修改和删除文件。
- 区别：
  - 提供对文件系统的访问，可以进行文件操作。
  - 需要用户授权。
- 应用场景：
  - 离线应用程序的文件存储和管理。
  - 需要直接访问用户文件系统的应用。

> 应根据具体的需求和场景选择合适的本地存储方式。如果只需要存储少量的用户数据或简单的键值对，可以使用 Cookie 或 Web Storage。如果需要存储大量的结构化数据，可以考虑使用 IndexedDB。如果需要进行文件操作或访问用户文件系统，可以使用 FileSystem API。



### js中内存泄漏的几个原因

**全局变量**

在JS中，全局变量会一直存在于内存中，直到页面关闭。如果不小心创建了一个全局变量，而且没有及时清除它，就会导致内存泄漏。为了避免这种情况，应该尽量避免使用全局变量，而是使用局部变量。

**闭包**

闭包是指一个函数可以访问另一个函数内部的变量。如果一个函数返回了一个闭包，而且这个闭包中包含了一些不再需要的变量，那么这些变量就会一直存在于内存中，导致内存泄漏。为了避免这种情况，应该尽量避免使用闭包，而是使用其他方式实现相同的功能。

**定时器**

定时器是一种常见的JS功能，但是如果不小心使用了错误的方式创建定时器，就会导致内存泄漏。例如，如果使用了setInterval函数而没有及时清除它，就会导致定时器一直存在于内存中，导致内存泄漏。为了避免这种情况，应该使用setTimeout函数，并在定时器执行完毕后及时清除它。

**DOM元素**

在JS中，DOM元素也会占用内存。如果不小心创建了大量的DOM元素，而且没有及时清除它们，就会导致内存泄漏。为了避免这种情况，应该尽量避免创建大量的DOM元素，而是使用其他方式实现相同的功能。		

### 如何通过原生js实现一个节流函数和防抖函数，写出核心代码，不是简单的思路？     

> 节流函数和防抖函数都是为了防止一个事件频繁触发而设计的，但是具体的实现方法有些不同
>
> 节流函数是指在一段时间内只能执行一次函数，如果在执行函数期间触发函数，则不会调用

```javascript
function(fn,time){

   let timer;

   if(!time){ // time为false时才会触发函数体

      timer = setTimeout(()=>{
          fn()

          timer = null

       },time)

   }

}
```

> 防抖函数是指延迟执行函数，比如延迟一秒执行。如果在执行期间再次触发该函数会停止上一次的函数，并运行本次的函数

```javascript
function(fn,time){

     let timer;

     clearTimeout(timer)//先清理后执行，这样在执行中的函数会被清理掉并执行新的函数

     timer =  setTimeout(()=>{

           fn() 

     },time)

}
```



### for...in循环和for...of循环的区别？

> 1. 遍历对象属性：for...in循环可以遍历一个对象的所有可枚举属性（包括自有属性和继承属性），而for...of循环不可以遍历对象属性。
> 2. 遍历数组下标或元素：for...in循环通过对象键名遍历数组下标或者对象属性，而for...of循环则通过数组元素值遍历数组。可以看出，如果我们使用for...in循环遍历数组时，可能会得到意外结果，比如输出“length”这个键名。
> 3. 遍历顺序：for...in 循环是无序的，而for...of循环是有序的。



### Js数据类型判断都有哪几种方式？至少说出5种？它们的区别是什么？

> 在JavaScript中，数据类型判断有以下几种方式：
>
> 1. typeof操作符：可以返回一个字符串，表示当前值的类型。它可以用来判断基本数据类型（除了null），以及函数、对象等引用类型。如typeof 123将返回"number"。
> 2. instanceof操作符：可以检测当前实例是否是指定类型的实例，可以用来判断自定义的复杂数据类型和内置的引用类型。如[1,2,3] instanceof Array将返回true。
> 3. Object.prototype.toString.call方法：可以判断基本数据类型、引用类型、以及内置对象类型。它返回的是"[object XXX]"，其中XXX代表当前值的类型。如Object.prototype.toString.call("hello")将返回"[object String]"。
> 4. constructor属性：可以获取当前对象的构造函数，从而进行类型判断。如"abc".constructor === String将返回true。
> 5. isArray方法：可以判断当前值是否为数组，仅适用于判断数组类型。如Array.isArray([1,2,3])将返回true。
>
> 这些方式均可用于数据类型的判断，但其使用场景、返回结果、效率等方面略有差别。其中，typeof操作符是最常见的类型判断方式，但对于某些类型（如null）返回的结果不够准确；instanceof操作符适用于复杂数据类型的判断，但只能精确地判断是否是某个类的实例；Object.prototype.toString.call方法适用范围比较广泛，但返回结果需要手动解析；constructor属性只适用于判断对象类型，并且有可能被改变；isArray方法则仅适用于数组的判断，但是由于其专门针对数组做了优化，具有较高的性能。



### 说说你对Object.defineProperty()的理解？

> Object.defineProperty()方法是JavaScript中常用的一个对象定义方法，主要作用是定义对象的属性。通过该方法可以为一个对象添加新的属性
>
> `Object.defineProperty(obj, prop, descriptor)`
>
> 参数**obj代表需要定义属性的对象，参数prop代表属性名，参数descriptor是表示该属性的描述符对象**。描述符对象有两种类型：
>
> 1. **数据描述符**：用于定义数据属性的特性，包括value（属性的值）、writable（是否可写）、enumerable（是否可枚举）、configurable（是否可配置）。
> 2. **存取描述符**：用于定义访问器属性的特性，包括**get和set方法**（获取和设置属性值的函数）、enumerable、configurable。
>
> ```javascript
> const person = {}// 空对象
> 
> // 添加数据描述符
> Object.defineProperty(person, 'name', {
>   value: 'Alice',
>   writable: false,
>   enumerable: true,
>   configurable: false
> })
> 
> // 添加访问器描述符
> let ageVal = 25
> Object.defineProperty(person, 'age', {
>   get() {
>     return ageVal
>   },
>   set(value) {
>     if (typeof value !== 'number') {
>       throw new TypeError('Age must be a number')
>     }
>     ageVal = value
>   },
>   enumerable: true,
>   configurable: false
> })
> 
> console.log(person.name) // 输出： Alice
> console.log(person.age) // 输出： 25
> 
> person.age = 30 // 设置属性值为30
> console.log(person.age) // 输出： 30
> 
> person.age = 'thirty' // 抛出错误：Age must be a number
> ```



### 说说AMD、CMD、commonJS模块化规范的区别？

1. AMD（Asynchronous Module Definition）：**异步**模块定义。AMD采用异步加载方式，**在多个模块之间并行加载**，可以有效避免页面等待和阻塞，提高性能。主要实现机制是**通过define函数来定义一个模块**，依赖关系通过回调函数参数声明，并且使用**require函数进行加载**。范例：

   ```
   复制代码define(['a', 'b'], function(a, b) {
     // 模块代码
   });
   ```

2. CMD（Common Module Definition）：通用模块定义。CMD跟AMD很相似，也是**异步**加载模块，但它采用了就近依赖方式，而不是预先声明依赖关系，这样使得代码更加简洁清晰；此外，**CMD支持延迟执行**，只有在真正需要时才加载某个模块。主要实现方式是通过**define和require两个函数来实现模块化**。例如：

   ```
   复制代码define(function(require, exports, module) {
     var a = require('./a');
     a.doSomething();
     // 模块代码
   });
   ```

3. CommonJS：**npm的模块规范**，JavaScript社区一度普及的服务器端模块标准。**CommonJS是同步加载模块**，采用**require方法加载模块**，通过**module.exports导出模块**，主要应用于后端和Node.js环境中。例如：

   ```
   复制代码// 定义模块
   var a = require('./a');
   function b() {
     // 模块代码
   };
   module.exports = {
     b: b
   };
   ```



### 说说package.json中版本号的规则？

> 版本号是由三个数字组合而成，分别表示**主版本号、次版本号和修订号**。每升级一个版本，其中的一个或多个数字会有所变化，这样做可以让用户知道新版本带来了哪些变化。符号**“^”、“~”等操作则可以指定版本范围**。



### 说说你对koa中洋葱模型的理解？

> Koa中的洋葱模型是指**将一个请求从外到内依次经过多个中间件处理，然后再从内到外依次经过这些中间件处理**，最终得到响应的过程。每个中间件负责对请求或响应进行一些操作。**整个过程形成了像洋葱一样层层嵌套的结构，因此被称为洋葱模型。**



### CDN的特点及意义？

> 1. 加速访问速度
> 2. 提高访问稳定性
> 3. 优化带宽利用率
>
> 意义：**提升用户体验、减轻服务器压力、为企业减少运营成本**



### ![] == ![]，![] == []，结果是什么？为什么？

> **true 和  false**
>
> 1  **[] 转换成布尔值为true** ，!取反就是false，所以两个false相比是相等所以返回true
>
> 2 左边为false，右边为true。结果自然是false



### 什么是闭包，应用场景是什么？

> 闭包就是在一个函数中返回一个函数。例如
>
> ```javascript
> function fn1(){
> 
>      return function fn2(){
> 
>         console.log(‘触发’)
> 
>      }
> 
> }
> ```
>
> 作用：
>
> **保护局部变量**：将函数内部作用域中的变量保护起来
>
> **记忆状态**：虽然我们执行了外部的函数，还可以访问内部的变量和函数等
>
> **应用场景**：模块封装、事件监听、面向对象编程



### 说说实现图片懒加载的思路？

> 1. 将图片的真实地址存储在一个自定义的属性中，例如`data-src`。初始时，将图片的`src`属性设置为占位图或空白图片。
>
> 2. 监听滚动事件或其他触发条件，当图片进入可视区域时触发加载。
>
> 3. 在触发条件满足时，将保存在`data-src`属性中的真实图片地址赋值给`src`属性，从而触发图片的实际加载。
>
> 这种实现方式可以减少页面首次加载时的图片请求量，提高页面加载速度和用户体验。以下是一个简单的示例代码：
>
> HTML:
>
> ```html
> <img class="lazy-image" data-src="path/to/real-image.jpg" src="path/to/placeholder-image.jpg" alt="Alt Text">
> ```
>
> JavaScript:
>
> ```javascript
> window.addEventListener('scroll', function() {
>   var lazyImages = document.querySelectorAll('.lazy-image');
> 
>   lazyImages.forEach(function(image) {
>     if (isElementInViewport(image)) {
>       image.src = image.dataset.src;
>       image.classList.remove('lazy-image');
>     }
>   });
> });
> 
> function isElementInViewport(element) {
>   var rect = element.getBoundingClientRect();
>   return (
>     rect.top >= 0 &&
>     rect.left >= 0 &&
>     rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
>     rect.right <= (window.innerWidth || document.documentElement.clientWidth)
>   );
> }
> ```
>
> 上述代码中，通过监听滚动事件来检查`.lazy-image`元素是否进入了可视区域。一旦进入可视区域，将真实图片地址赋值给`src`属性，并移除`.lazy-image`类，这样就触发了图片的加载。需要注意的是，代码中使用了`isElementInViewport`函数来判断元素是否在可视区域内。
>
> 当然，实际应用中还可以根据需求进行更加复杂的优化，例如添加延迟加载、预加载等功能，以提升图片加载性能和用户体验。

### 说说你对ES6模块化的理解？和commonJS的区别？

> ES6模块化与CommonJS模块化的主要区别包括：
>
> 1. 导入和导出方式：ES6模块化使用`import`和`export`关键字，而CommonJS使用`require()`和`module.exports`。
> 2. 编译时加载和运行时加载：ES6模块化在编译时进行静态分析和加载，可以进行静态优化；而CommonJS在运行时加载模块，无法进行静态优化。
> 3. 默认导出：ES6模块化支持默认导出，一个模块只能有一个默认导出；而CommonJS没有原生的默认导出。
> 4. 浏览器兼容性：ES6模块化需要现代浏览器的支持，而CommonJS可以在Node.js环境中直接使用。
> 5. 循环依赖处理：ES6模块化可以处理循环依赖，而CommonJS在处理循环依赖时会返回未完全初始化的模块对象。
>
> 总结来说，ES6模块化是一种更加现代化、语言层面的模块化规范，具有静态优化和默认导出等特性；而CommonJS是一种适用于Node.js的模块化方案，主要用于服务器端开发。

### import * as  from和import from有什么区别

在 ES6/ES2015 中，`import` 关键字用于导入模块，可以使用两种不同的语法来导入模块：`import * as` 和 `import`。

1. **`import * as`**：
   
   - 使用 `import * as` 语法，可以将整个模块的导出内容作为一个对象导入，对象的键是导出的标识符，值是导出的值。
   - 这种方式适用于导入模块中的所有导出成员，可以方便地使用对象的属性来访问导出的内容。
   
   ```javascript
   // 模块 foo.js 导出了两个变量：a 和 b
   // foo.js
   export const a = 10;
   export const b = 20;
   
   // 在另一个文件中使用 import * as 导入模块的内容
   // main.js
   import * as fooModule from './foo.js';
   
   console.log(fooModule.a); // Output: 10
   console.log(fooModule.b); // Output: 20
   ```
   
2. **`import`**：
   - 使用 `import` 语法，可以单独导入模块中的特定成员，而不需要将它们放在一个对象中。
   - 这种方式适用于只需要导入模块的部分内容，可以按需导入特定的标识符。

   ```javascript
   // 模块 bar.js 导出了两个变量：x 和 y
   // bar.js
   export const x = 30;
   export const y = 40;
   
   // 在另一个文件中使用 import 导入模块的部分内容
   // main.js
   import { x } from './bar.js';
   
   console.log(x); // Output: 30
   ```

总结：

- `import * as` 用于导入整个模块的内容，并将其封装为一个对象，通过对象的属性来访问导出的成员。
- `import` 用于单独导入模块的特定成员，可以按需导入需要的标识符。
- 选择使用哪种方式取决于对模块导出的内容的需求，如果需要导入所有导出成员并以对象的形式访问，可以使用 `import * as`，如果只需要导入特定的成员，可以使用 `import`。

### babel是什么，有什么作用?

> Babel是一个广泛使用的JavaScript编译器工具，它主要用于将新版本的JavaScript代码转换为向后兼容的旧版本，以确保在不同浏览器和环境中的兼容性。
>
> Babel的作用包括以下几个方面：
>
> 1. 语法转换：Babel可以将使用了较新语法特性的JavaScript代码转换成向后兼容的版本，以便在旧版JavaScript引擎上运行。例如，将ES6/ES7的箭头函数、扩展运算符等转换为ES5兼容的代码。
>
> 2. Polyfill填充：Babel可以根据目标环境的需求自动添加缺失的新API的polyfill（垫片），使得开发者可以使用最新的JavaScript API而不必担心浏览器兼容性问题。例如，通过Babel的一些插件，可以为旧版浏览器添加Promise、Map、Set等新的API。
>
> 3. JSX转换：Babel可以将JSX语法转换为普通的JavaScript代码，以便在不支持JSX的环境下进行正确渲染。这对于React等基于JSX的库和框架十分重要。
>
> 4. 插件扩展能力：Babel提供了丰富的插件系统，可以根据项目需求定制转换规则。开发者可以编写自定义插件来处理特定的转换需求，或使用社区提供的插件来支持更多的语法和特性。
>
> 总结来说，Babel是一个用于编译JavaScript代码的工具，它可以将新版本的JavaScript代码转换为向后兼容的旧版本，以提高代码在不同环境中的兼容性。它还支持JSX转换和polyfill填充等功能，通过插件扩展能力，使得开发者可以根据项目需求进行定制化配置和转换。



### ES5、ES6和ES2015有什么区别?

> ES5、ES6和ES2015都是JavaScript的版本标准，它们之间存在以下区别：
>
> 1. ES5（ECMAScript 5）：发布于2009年，是目前广泛支持的JavaScript标准。ES5引入了一些重要的语法和特性，如严格模式（strict mode），JSON对象，数组方法（如forEach、map、filter等），Function.prototype.bind()等。
>
> 2. ES6（ES2015）：发布于2015年，是 JavaScript中一次重大的更新，引入了许多新的语法和特性。ES6包含了对变量声明（let、const）、箭头函数、类（class）、模块化（import/export）以及解构赋值等方面的扩展，还新增了Promise、生成器（generator）等功能。
>
> 3. ES2015（ECMAScript 2015）：ES2015是ES6的另一个名称，两者指的是同一个JavaScript版本。ES2015是ECMAScript委员会在2015年正式发布的规范，但由于ES6这个名称更为常用，ES2015通常被称为ES6的旧称。
>
> 总结起来，ES5是2009年发布的JavaScript标准，ES6/ES2015是2015年发布的JavaScript标准，它们分别引入了不同的语法和特性，使得JavaScript语言更加强大和灵活。开发者可以根据目标环境和需求选择使用相应的版本。需要注意的是，ES6/ES2015及其之后的版本并非所有浏览器都完全支持，因此在开发时需要考虑兼容性并使用转译工具（如Babel）进行代码转换。



### Proxy 相比于 defineProperty 的优势

> Proxy和Object.defineProperty都是用于拦截对对象的操作，但Proxy相比于defineProperty有以下优势：
>
> 1. 拦截更多操作：Proxy可以拦截更多种类的操作，包括属性访问、函数调用、构造函数调用、in运算符、delete运算符等。而defineProperty仅能拦截属性的读取和赋值操作。
>
> 2. 更细粒度的拦截控制：Proxy提供了丰富的拦截方法（handler），每个方法对应一个操作，可以根据需要选择性地进行拦截。这使得开发者可以更加灵活地控制行为，并实现更复杂的拦截逻辑。
>
> 3. 避免破坏性修改：使用Object.defineProperty直接修改对象的属性描述符时，会对原对象产生破坏性修改。而Proxy在原对象上创建一个代理，不会直接修改原对象，从而避免了破坏性修改。
>
> 4. 直观易用的API：Proxy提供了一组直观易用的API，例如get、set、apply等方法，使用起来更加简洁明了。相比之下，Object.defineProperty需要手动编写getter和setter函数。
>
> 5. 支持数组和Map等数据结构：Proxy可以完全代理数组和Map等内置对象，而defineProperty无法对数组的索引进行拦截。
>
> 需要注意的是，由于Proxy是ES6引入的新特性，某些老旧浏览器可能不支持。因此，在使用Proxy时需要注意兼容性，并考虑使用polyfill或降级方案来处理不支持的情况。另外，由于Proxy的功能更强大，性能也相对较低，因此在关注性能优化时需要进行评估和测试。

### Promise的理解，状态，处理

`Promise`是`ES6`中新增的语法，它的应用场景是用来解决异步函数，解决回调函数的回调地狱问题。

`promise`的三种状态：

- `pending`初始化的状态没有做任何操作
- `fullfiled`已经完成的状态
- `rejected`失败之后的状态

`new Promise((resolve,reject)=>{})`

> promise默认接收一个回调函数，这个回调函数用来处理promise中的状态和响应。通过resolve将pending状态改变为fullfiled状态；通过reject将pending状态改变为rejected状态

处理状态的多种方法：

- `.then()`用于处理`fullfiled`的响应回调
- `.catch()`用于处理rejected拒绝之后的回调
- `.finally()`不管是成功还是失败都会触发这个方法
- `Promise.all()`接收一个数组，数组中的元素是promise对象，通过`.then`可以接收数组中所有promise的结果
- `Promise.race()`接收一个数组，这个方法只关心最先执行完毕的promise对象。

# CSS

### 盒子模型的理解

> 盒子模型指的是，在浏览器页面中可以将，每个元素看做一个盒子而盒子是由内容content、内边距padding、边框border、外边距margin组成
>
> 内容content：可以设置一些字体样式、宽高等
>
> 内边距padding：可以设置盒子的内容距离盒子边缘的像素值，具体的属性有padding-top、bottom、left、right
>
> 边框border：可以设置边框的样式比如虚线、实线、双实线、颜色、边框的宽度等
>
> 外边距margin：可以设置盒子和外侧盒子的距离。通过属性margin-top、bottom、left、right
>
> 
>
> 盒子模型所涉及到一些概念：
>
> 内容溢出：当元素的内容超出了盒子的宽高时我们可以通过overflow属性将超出部分隐藏或者显示滚动条
>
> 怪异盒子：当元素设置了padding之后会出现盒子的宽高变化，这是需要设置box-sizing：border-box；属性将盒子的宽高固定
>
> 盒子的定位：通过position、float将盒子定位，实现一些布局效果



### CSS中的选择器，优先级，哪些属性可以继承

> **选择器有：**
>
> 1. 标签选择器：例如`div`、`p`等标签
> 2. ID选择器：例如`<div id='box'><div>`以id命名的元素，在css中通过`#box{}`设置它的样式
> 3. class选择器：例如`<div class='box'><div>`以id命名的元素，在css中通过`.box{}`设置它的样式
> 4. 通配符选择器：例如`*{}`它的特点是：样式会将页面中所有元素的样式起作用，且优先级最低
> 5. 后代选择器：例如`div p`它的意思是`div`标签中所包裹的`p`标签
> 6. 子选择器：例如`ul > li`它的意思是`ul`的第一个子标签`li`
> 7. 相邻选择器：例如`.p1 + .p2`它的意思是两个元素相邻，父节点是一个
> 8. 伪类选择器：对指定`:hover`鼠标进入、`:visited`被访问过的链接、`:active`鼠标按下、`:link`没有访问的链接、`:nth-child`父节点的第（n）个子节点、`first-child`第一个子节点、`last-child`最后一个子节点
>
> **优先级：**
>
> 权重值越大优先级越大
>
> 内联样式：在标签内部style标签中的样式；权重1000
>
> id选择器：权重100
>
> class选择器、伪类选择器、属性选择器：权重10
>
> 标签选择器、伪标签选择器：权重1
>
> 后代选择器的权重根据所有选择器的权重值相加
>
> 通配符选择器为0
>
> 可以通过`!important`将加强优先级
>
> **继承：**
>
> 通过`inherit`属性值来继承父级的样式
>
> 可以继承的属性有：
>
> - color
> - font-size
> - font-weight
> - border
>
> 等很多。
>
> 不支持继承的有：
>
> - position
> - width
> - height
> - top
> - bottom
> - left
> - right
>
> 等



### 怎么理解回流跟重绘？什么场景下会触发？

> - 回流是指在页面中的元素节点重新计算的过程。
>
>   当页面布局发生改变时，比如宽高的变化、元素的新增、删除、修改都会触发回流
>
>   回流的这个过程需要重新计算页面布局，是一种损耗性能的操作。
>
> 
>
> - 重绘是指不影响页面布局的情况下的样式修改，会触发重绘
>
>   修改字体大小时、颜色、背景色等等，只要样式不影响布局就只会触发重绘的操作
>
>   重绘的操作不会损耗性能。如果修改的字体大于了原本盒子的宽高，这是触发的是回流
>
> 在初次渲染页面时会同时触发回流重绘的操作



### 谈谈你是如何做移动端适配的？

> viewport 设置 \<head> 中的 \<meta>
>
> CSS单位vh/em99/rem
>
> 媒体查询 @media 通过当前的宽度来判断字体的大小等



### 移动端1像素的解决方案？

 

> 1px问题是指**高分辨率的设备上**，由于像素密度过大，**出现线条变粗或消失的情况**
>
>  
>
> 解决方案有**CSStransform:scale()**来缩放元素尺寸、**viewport**来进行缩放、**JavaScript**适配缩放



### 弹性盒中的缩放机制是怎样的

> 弹性盒中的项目设置**flex-grow**属性定义项目的放大比例，默认值为0，值越大，放大越厉害，且不支持负值； 
>
> 而**flex-shrink**属性定义项目的缩小比例，默认值为1，数值越大，缩小越厉害，同样不支持负值；



### 如何使用css实现一个三角形

> - **颜色渐变**
>
>   background: linear-gradient(45deg, red, red 50%, transparent, transparent 50%);  
>
> 
>
> - 设置边框
>
>   div  {
>
> ​             width: 0px;
>
> ​             height: 0px;
>
> ​             border-top: 50px solid transparent;
>
> ​             border-bottom: 50px solid deeppink;
>
> ​             border-left: 50px solid transparent;
>
> ​             border-right: 50px solid transparent;
>
> }     



### 说说设备像素、css像素、设备独立像素、dpr、ppi之间的区别？

> 设备像素、css像素、设备独立像素、dpr、ppi是Web开发中常提到的概念，其中：
>
> - 设备像素是硬件上的物理像素点；
> - CSS像素是CSS里最基本的单位，在不同的设备和尺寸下，显得比较固定；
> - 设备独立像素是和设备无关的抽象长度单位，主要用于解决多种环境下样式难以统一的问题；
> - dpr是指在同样物理尺寸下，屏幕上用来显示一个CSS像素的设备像素的数量；
> - ppi是指每英寸的像素数，可以用来描述设备的像素显示精度。
>
> 通俗地讲，设备像素指的是硬件上的实际像素，CSS像素指的是我们写样式时使用的书写量，而**设备独立像素**则是在移动端应用开发中常用的概念，**主要是为了解决不同分辨率设备上样式呈现矛盾的问题**。dpr表示同样大小下，屏幕上用来显示一个CSS像素的物理像素的数量，而ppi量化了某个设备在单位面积内有多少个像素，即密度。这些概念不仅帮助前端开发者更好地调整设计样式，还可以提升设备的画质表现。





### 谈谈你对BFC的理解？

> BFC（Block Formatting Context）块级格式化上下文，是指一个独立的渲染区域，在这个区域中，所有的元素放置的位置都不会影响到外部元素，同时该区域也与外部毫无关系。简单来说，BFC就是一个独立容器，容器内的元素按照一定规则布局，而与BFC外部的元素无关。
>
> 通过触发 BFC 可以解决一些常见的布局问题，如浮动元素引起的高度塌陷或边距重叠等。在触发 BFC 时有以下几种情况：
>
> 2. 浮动元素 (元素的 float 不为 none)；
>
> 3. 绝对定位元素 (元素的 position 为 absolute 或 fixed)；
>
> 4. 行内块元素 (元素的 display 为 inline-block)；
>
> 5. 表格单元格 (元素的 display为 table-cell，HTML表格单元格默认属性)；
>
> 6. overflow 值不为 visible 的块元素；
>
> 7. 弹性元素 (display: flex 或 inline-flex 元素的子元素)。
>
> 当一个元素成为 BFC 后，它内部的子元素会按照一定规则进行排列，可以**阻止外部元素和内部元素之间的相互影响**，**避免边距重叠等问题**。



### 最少说出三种前端清除浮动的方法？

> 以下是常用的三种清除浮动方法：
>
> 1.父元素设置高度：在父元素结束标签前添加一个空 div 标签，并且给这个标签设置 clear:both 属性。
>
> 2.使用 clearfix 类：在父元素上添加 clearfix 类，提供以下样式：
>
> ```
> .clearfix::after {
>   content: "";
>   display: table;
>   clear: both;
> }
> ```
>
> 3.使用 overflow:hidden 或 overflow:auto：在父元素上设置 overflow 属性为 hidden 或 auto，触发 BFC 形成，则可以清除内部浮动。
>
> ```css
> .parent {
>   overflow: hidden; /* 或者设置 overflow: auto; */
> }
> ```



# 其他Web相关面试题



### 说说TCP为什么需要三次握手和四次握手？

> TCP是一种面向连接的可靠传输协议，使用三次握手来建立连接、四次握手来关闭连接。
>
> 为了确保通信双方都认可建立连接，TCP使用三次握手。说得简单点，可以这样理解：Client端发送Syn请求，Server端返回Syn+Ack确认，Client端再发送Ack确认，至此连接建立成功。
>
> 同样地，为了在终止前先告知对方并确保数据已经完整传输，TCP使用四次握手来关闭连接。首先，Client端向Server端发送Fin请求，告知自己准备关闭连接；接着，Server端返回Ack确认，并暂停向Client端发送数据；等 Server 端这边也没有需要传输的数据时，会向 Client 发送Fin请求，告知自己也准备关闭连接；最后，Client端返回Ack确认，关闭连接。
>
> 通过三次握手和四次握手，TCP可以保证连接的可靠性和正确性，防止因网络中的不可靠因素导致数据传输中的错误。

### 什么是单点登录？如何实现？

> **单点登录**理解比如在一家公司的**一个产品中注册了一个账号**，登录了。当我们再次进入他旗下的其他产品是会不用再去注册了，会直接登录。
>
> 
>
> 用户访问一个需要**身份验证的应用程序**。
>
> 应用程序检测到**用户未登录**，将用户重定向到认证中心。
>
> 用户在认证中心登录并提供凭证（用户名和密码）。
>
> 认证中心验证用户的凭证，如果凭证有效，则生成一个令牌。
>
> 认证中心将令牌返回给用户的浏览器，并将用户重定向回应用程序。
>
> 用户的浏览器将令牌传递给应用程序。
>
> 应用程序接收到令牌后，将其发送到认证中心进行验证。
>
> 认证中心验证令牌的有效性，并确认用户的身份。
>
> 应用程序信任认证中心的验证结果，将用户标记为已登录状态。
>
> 用户可以访问应用程序的受保护资源。

### 描述浏览器的渲染过程，DOM 树和染树的区别

浏览器的渲染过程可以分为以下几个步骤:

1. 解析HTML构建DOM树:浏览器首先会解析HTML文档,构建一个内容为DOM节点的DOM树。
2. 构建CSSOM树:浏览器会解析CSS代码,生成CSSOM树,里面存储着CSS样式规则。
3. 构建Render树:浏览器会将DOM树和CSSOM树结合,生成Render树。Render树中包含了页面需要渲染的所有节点信息以及节点的样式信息。
4. 布局Render树:浏览器会计算出Render树中每个节点的位置和大小,这个过程称为布局。
5. 绘制:浏览器会将Render树中的节点绘制到屏幕上,显示页面内容。
6. 合成:浏览器会将页面的不同层进行叠加,显示成完整的页面图像。

DOM树和Render树的主要区别在于:

- DOM树直接来自HTML文档,包含了页面的DOM节点。
- Render树包含了页面渲染所需要的DOM节点以及CSS样式信息。
- DOM树主要描述内容,Render树描述如何显示内容。
- DOM树的修改会重新构建Render树。
- Render树决定了页面的显示效果。

### http 请求报文响应报文的格式

 HTTP请求报文和响应报文都由多行数据组成,并遵循类似格式。
HTTP请求报文格式:

```
请求行
请求头部字段1
请求头部字段2 
...
请求头部字段N
空行 
请求数据
```
示例:
```
GET /index.html HTTP/1.1
Host: www.example.com
Connection: keep-alive
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0
Accept: text/html
(请求数据)
```
HTTP响应报文格式:
```
状态行
响应头部字段1  
响应头部字段2
...
响应头部字段N
空行
响应数据
```
示例:
``` 
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 12345
Connection: keep-alive
Date: Thu, 04 Jun 2020 12:51:29 GMT
Server: Apache/2.2.14 (Win32) 
(响应数据)
```
请求行和状态行分别包含请求方法、URL、协议版本和响应状态码、协议版本。
头部字段包含请求和响应的元信息。
空行用于分割头部字段和数据体。
数据体包含请求或响应的数据内容。



### Axios的前置、后置拦截器

**关键字`interceptore`**

**前置**

`axios.interceptore.request.use((config)=>{}, (err)=>{})`

> 两个参数，均为函数；第一个为处理的请求本身，可以另加请求头等操作；第二个为错误处理，当报错会将错误处理在控制台，而不是终止整个程序

**后置**

`axios.interceptore.response.use((res)=>{}, (err)=>{}))`

> 同样两个参数；第一个为每次请求时的返回数据；第二个为错误处理



### svg和canvas的区别

1. svg是矢量图，可以使图像无限放大，也不会失真
2. 一个svg矢量图是一个XML格式的DOM元素
3. canvas要通过js控制来显示不同的效果
4. canvas中的内容不是一个DOM元素
5. canvas不是矢量图，放大会有马赛克的问题



### Echarts是怎么理解的

这是一个展示信息图表，包含了折线图、柱状图、雷达图等等，包括一些额外的功能比如动画、事件、数据等，都是为了提高流畅性，让用户体验感加强。通过svg或者canvas实现，主要是通过浏览器所支持的自动选择。



### H5的理解

1. 新增了语义化标签比如header、footer、nav等
2. 新增视频和音频标签而无需flash
3. 浏览器缓存
4. websocket
5. webworker
6. canvas
7. 像我们现在应用到的表单控件大部分都是新增的

### token和cookie的区别

1. 从存储位置上来说，token是存储在后端服务器当中的而cookie是存储在客户端当中
2. 跨域角度来说因为token是在服务器当中的所以跨域没有问题，而cookie就需要额外的配置比如`SameSite设置为None`或者`在后端服务器中开启CORS`才可以开启跨域
3. 从安全性来说token相对来说更安全，而cookie可能会受到xss或者CSRF的攻击但是可以通过配置`httpOnly`选项只允许请求访问而不允许js的方式访问



### XSS和CSRF的区别

1. XSS会通过js脚本的方式恶意读取信息，CSRF会在用户登录的情况下发送一些恶意的请求
2. 防止XSS就可以通过一些转义或者过滤的方式减少、CSRF可以在后端做一些校验

# Git

### 说说git中head、工作树和索引之间的区别？

> 1. HEAD：
>    - HEAD 是当前所在的分支的引用，也可以理解为指向当前提交（commit）的指针。
>    - HEAD 始终指向最近一次提交的引用，它可以用来获取最新提交的内容，例如查看最新提交的日志或回退到上一个提交。
> 2. 工作树（Working Tree）：
>    - 工作树是指在你的本地文件系统中的目录，它包含着当前检出（checkout）的分支的所有文件和目录。
>    - 当你检出一个分支或者切换到一个提交时，Git会将对应的文件从仓库中复制到工作树中，以供你进行编辑和修改。
>    - 工作树中的文件可以被添加、修改或删除，这些修改只会存在于你的本地，直到你将其提交到仓库中。
> 3. 索引（Index）：
>    - 用于存储你打算提交到仓库的更改。
>    - 当你对工作树中的文件进行修改后，需要使用 `git add` 命令将修改后的文件添加到索引中。
>    - 索引相当于一次提交的预备区域，你可以将多个文件的更改暂时保存在索引中，然后一次性提交到仓库中，形成一个新的提交。
>    - 通过使用 `git commit` 命令，Git会将索引中的内容提交到仓库，并创建一个新的提交。
>
> **简而言之：**
>
> - **HEAD 是指向当前提交的指针，它指示你正在哪个分支上工作。**
> - **工作树是你的本地文件系统中的目录，包含着你当前检出的分支的文件和目录。**
> - **索引是一个中间区域，用于暂存你打算提交到仓库的更改，它允许你对多个文件的更改进行分批提交。**
